#===============================================================================
# AlloHubMat
#' Automated detection of ergodic sectors from a list of time-averaged mutual information matrices.
#' 
#' This function takes an input matrix and extract so-called ergodic sectors. The input is a single
#' matrix generated by matrix_smooth(), and returns a summary of any detected ergodic sectors, and
#' when they occur in the MD simulation.
#'
#' @param overlap.matrix.s Smoothed matrix of covariance overlaps, computed using matrix_smooth()
#' @param sBlock trajectory block size (in ns)
#' @return Returns a dataframe containing a summary of any detected ergodic sectors, including the 
#' time in the MD trajectory in which they occur
#' @export 
#===============================================================================

detect_sectors = function(overlap.matrix.s, sBlock){

	## vector containing the diagonal of the smoothed covariance matrix
	sector.v = diag(overlap.matrix.s$z)

	## split the diagonal into sectors, here done for each quantile
	sector.liv = sapply(quantile(sector.v), function(x) x > sector.v)


	## the 'FALSE' sectors at 75% should be useful
	sector.sel.niv = which(! sector.liv[ ,"75%"])

	sector.idx = 1

	sector.idx.v = vector(length = length(sector.sel.niv))

	sector.idx.v[1] = sector.idx


	## count non-index-contiguous blocks
	for (i in 2:length(sector.sel.niv)) {

		if (sector.sel.niv[i-1] != sector.sel.niv[i] - 1) {

			sector.idx = sector.idx + 1

		}

		sector.idx.v[i] = sector.idx;
	}


	## translate block index vector into trajectory index vector
	sector.sel.tiv = sector.sel.niv * sBlock;

	## combine block index with trajectory index
	sector.info = rbind(sector.idx.v, sector.sel.niv, sector.sel.tiv)

	rownames(sector.info) = c("sector_ID", "block_idx", "traj_idx")

	# print out the time-indices of any detected ergodic sectors
	print(sector.info)

	# write the details of detected ergodic sectors to a file in the working dir
	print('Writing details of ergodic sectors to current working directory')

	write.table(sector.info,
		file = 'sector.info')

	## return the ergodic sector information
	return(sector.info)

}

#===============================================================================
#' Extract the ergodic sectors from a trajectory of mutual information matrices.
#' 
#' This function takes the list of mutual information matrices <output of read_mats()> with the detected ergodic
#' sectors <output of detect_sectors()>, and extracts the ergodic sectors from the trajectory of mutual information
#' matrices. The function returns a list of averaged ergodic sectors, 
#' matrix generated by matrix_smooth(), and returns a list of ergodic sectors.
#'
#' @param sector.info a dataframe containing a summary of any detected ergodic sectors, including the 
#' time in the MD trajectory in which they occur. Output of detect_sectors().
#' @param MImatlist First eigenvector considered in computing the covariance overlap
#' @return A list of matrices, each is an averaged mutual information matrix for an ergodic sector
#' @export
#===============================================================================

extract_sectors = function(sector.info, MImatlist){


	sector.cont.ind = denstrip::seqToIntervals(sector.info[2,])
	nSectors.cont = nrow(sector.cont.ind)
	sector.cont = list(nSectors.cont)

	dimx = nrow(MImatlist[[1]])
	dimy = ncol(MImatlist[[1]])

	sectors = list()

	## find contiguous sectors and add them to list "sectors"
	for (i in 1:nSectors.cont){

		from = sector.cont.ind[i,1]
		
		to = sector.cont.ind[i,2]
	
		## subset the contiguous sectors and find the element-
		## wise average of the sector
		submat = MImatlist[from:to]
		
		Y = do.call(cbind, submat)
		
		Y = array(Y, dim=c(dim(submat[[1]]), length(submat)))

		sectors[[i]] = apply(Y, c(1, 2), mean, na.rm = TRUE)


		## write the element-averaged sectors to files	
		print(paste('Writing sector #', i, ' to the current working directory'))

		write.table(sectors[[i]],
			file=paste(i,'_sector', '.sec', sep=''),
			col.names=F, row.names=F,
			sep=' ')

	}

	# return a list of matrices, each is an averaged mutual information matrix for an ergodic sector
	return(sectors)

}

#===============================================================================

