#===============================================================================
# AlloHubMat
#' 2-dimensional plot of the covariance overlap between continguous mutual information matrices, defined in the input trajectory.
#' 
#' This function generates a 2d plot of the diagonal of the smoothed covariance overlap matrix, generated by matrix_smooth().
#' The function generates a plot.
#'  
#' 
#'
#' @param overlap.matrix.s Smoothed matrix of covariance overlaps, computed using matrix_smooth().
#' @param t.traj Length of the MD simulation, in nanoseconds.
#' @return A plot 
#' @export
#===============================================================================

sectors_2dplot = function(overlap.matrix.s, t.traj){

	# take the diagonal of the covariance overlap matrix
	sector.v = diag(overlap.matrix.s$z)

	# determine a vector defining the trajectory time-sequence
	times = seq(from = 0, to = t.traj, length.out = length(sector.v))

	# combine time and covariance overlap values into a single dataframe
	dat = cbind(times, sector.v)

	# generate the plot to a pdf file
	par(mar = c(5,5,2,2))

	plot(dat,
		pch = 1,
		cex = 2,
		xlab = 'Time (ns)',
		ylab = expression(paste(Omega['A;B'])),
		panel.first = grid(lwd = 2),
		cex.axis = 2,
		cex.lab = 2,
		type = 'o')

}

#===============================================================================
# AlloHubMat
#' Image plot of the covariance overlap between all mutual information matrices defined in the input trajectory.
#' 
#' This function generates and image plot of the smoothed covariance overlap matrix generated by matrix_smooth().
#' The function generates an image plot.
#'  
#' 
#'
#' @param overlap.matrix.s Smoothed matrix of covariance overlaps, computed using matrix_smooth().
#' @param t.traj Length of the MD simulation, in nanoseconds.
#' @return An image plot 
#' @export
#===============================================================================

sectors_3dplot = function(overlap.matrix.s, t.traj){

	# determine a vector defining the trajectory time-sequence
	times = seq(from = 0, to = t.traj, length.out = ncol(overlap.matrix.s$z))

	# generate the image plot
	par(mar=c(5,5,2,2))

	fields::image.plot(times, times, overlap.matrix.s$z,
	        legend.cex=2,
	        cex=2,
	        xlab="Time (ns)",
	        ylab="Time (ns)")
}

#===============================================================================
# AlloHubMat
#' Plot the frequency distribution of the ergodic sector mutual information.
#' 
#' This function generates a frequency distribution plot of the mutual information contained by the ergodic sectors
#' identified by extract_sectors(), and calculates a significance cutoff to distinguish significant correlations
#' from the noise.
#'  
#' 
#'
#' @param sector.list A list of matrices, each is an averaged mutual information matrix for an ergodic sector
#' @param n.sigmas An integer number of standard deviations used in calculating the mutual information significance threshold (default value of 2)
#' @return A density histogram plot of the mutual information of the ergodic sectors
#' @export
#===============================================================================

sectors_MIfreq = function(sector.list, n.sigmas){

	# if the number of standard deviations is not specified by the user, assign default value of 2
	if(is.null(n.sigmas)){
		n.sigmas = 2
	}

	# if there are more than a single ergodic sector in the list, then average over the ergodic
	# sector mutual information matrices
	if(length(sector.list) > 1){
		
		# perform an element-wise averaging over the list of sector matrices
		# to determine the average mutual information matrix
		mat = Reduce("+", sector.list) / length(sector.list)

	} else {


		# if there is only a single ergodic sector identified in the MD trajectory, then use
		# the mutual information matrix of that single ergodic sector
		mat = sector.list[[1]]
	}


	# determine the average of the average mutual information matrix
	mu.mat = mean(mat)

	# determine the standard deviation of the average mutual information matrix
	sig.mat = sd(mat)

	# calculate the significance threshold
	threshold = mu.mat + (n.sigmas*sig.mat)

	# histogram of the average mutual information matrix
	mathist = hist(mat,
		plot=FALSE,
		breaks='Freedman-Diaconis')


	# plot the histogram
	par(mar = c(5,5,2,2))

	plot(mathist$breaks[-1],
		mathist$counts,
		type='h',
		xlab = "nMI",
		ylab = expression(italic(f(nMI))),
		cex.lab = 2,
		cex.axis = 2,
		panel.first = grid())
	
	# line denoting the significance threshold 	
	abline(v=threshold,
		lty=2,
		col="red",
		lwd=2)
	
	# text
	text(threshold + 0.3, (max(mathist$counts) / 2),
		paste("nMI > ", round(threshold, 3)),
		cex=2)
}

#===============================================================================

