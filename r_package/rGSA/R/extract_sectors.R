#' Extract the ergodic sectors from a trajectory of mutual information matrices.
#' 
#' This function takes the list of mutual information matrices <output of read_mats()> with the detected ergodic
#' sectors <output of detect_sectors()>, and extracts the ergodic sectors from the trajectory of mutual information
#' matrices. The function returns a list of averaged ergodic sectors, 
#' matrix generated by matrix_smooth(), and returns a list of ergodic sectors.
#'
#' @param sector.info a dataframe containing a summary of any detected ergodic sectors, including the 
#' time in the MD trajectory in which they occur. Output of detect_sectors().
#' @param MImatlist First eigenvector considered in computing the covariance overlap
#' @return A list of matrices, each is an averaged mutual information matrix for an ergodic sector
#' @export



extract_sectors = function(sector.info, MImatlist){


	sector.cont.ind = seqToIntervals(sector.info[2,])
	nSectors.cont = nrow(sector.cont.ind)
	sector.cont = list(nSectors.cont)

	dimx = nrow(MImatlist[[1]])
	dimy = ncol(MImatlist[[1]])

	sectors = list()

	## find contiguous sectors and add them to list "sectors"
	for (i in 1:nSectors.cont){

		from = sector.cont.ind[i,1]
		
		to = sector.cont.ind[i,2]
	
		## subset the contiguous sectors and find the element-
		## wise average of the sector
		submat = MImatlist[from:to]
		
		Y = do.call(cbind, submat)
		
		Y = array(Y, dim=c(dim(submat[[1]]), length(submat)))

		sectors[[i]] = apply(Y, c(1, 2), mean, na.rm = TRUE)


		## write the element-averaged sectors to files	
		print(paste('Writing sector #', i, ' to the current working directory'))

		write.table(sectors[[i]],
			file=paste(i,'_sector', '.sec', sep=''),
			col.names=F, row.names=F,
			sep=' ')

	}

	# return a list of matrices, each is an averaged mutual information matrix for an ergodic sector
	return(sectors)

}
		
