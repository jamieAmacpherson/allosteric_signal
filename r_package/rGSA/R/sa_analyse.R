#'  sa_analyse.R
#'
#'  [TT]g_sa_analyze[tt] performs advanced analyses on the alignment of structural,
#'  strings ([TT]-sa[tt]) produced by [TT]g_sa_encode[tt] (Pandini et al., FASEB J. [BB]26[bb], 868,
#'  (2012)).[PAR],
#'
#'  Option [TT]-MImatrix[tt] calculates the Mutual Information (MI) matrix between pairs,
#'  of columns (positions) in the alignment. The MI values are written to a ASCII,
#'  [TT].out[tt] file ([TT]-MImat[tt]). The normalized MI matrix ([TT]-nMImat[tt]), the joint entropy,
#'  matrix ([TT]-jHmat[tt]) and the expected finite size error matrix ([TT]-eeMImat[tt]) are also,
#'  calculated.[PAR],
#'
#'  The calculation of the statistically significance for the MI values can be requested,
#'  with [TT]-nSample[tt] > 0. A random background distribution of [TT]nSample[tt],
#'  samples is generated by shuffling the letters in each column of the,
#'  alignment. MI values averaged over the randomized samples ([TT]-meanMImat[tt]), the,
#'  associated standard deviations ([TT]-stdMImat[tt]), Z-scores ([TT]-ZMImat[tt]) and [TT]p-values[tt],
#'  ([TT]-pvalueMImat[tt]) are evaluated and written to ASCII [TT].out[tt] files.[PAR],
#'
#'  Option [TT]-trmat[tt] writes the transition probability matrix between pairs of SA,
#'  letters to an ASCII [TT].out[tt] file ([TT]-trans[tt]).[PAR],
#'
#'  A functional analysis can be requested by providing an [TT].xvg[tt] file with a,
#'  time-dependent function-related property ([TT]-fvalue[tt]). The MI values between,
#'  selected columns (positions) of the alignment and a discretized version of,
#'  the functional property are calculated. The positions in the alignment can be,
#'  selected providing a [TT].ndx[tt] file ([TT]-n[tt]). The column containing the functional,
#'  property in the [TT].xvg[tt] file can be specified with the [TT]-xvgcol[tt] flag. A summary,
#'  of MI statistics is written for each selected position to a separate [TT].log[tt],
#'  file ([TT]-MIlog[tt]). For visualization purposes, the discretized form of,
#'  the functional property and a numeric version of the structural string are,
#'  written for each selected position to a separate [TT].xvg[tt] file ([TT]-MIxvg[tt]) and to a,
#'  separate [TT].out[tt] file ([TT]-MIout[tt]).[PAR],
#'
#'  The same basic statistical analyses performed by [TT]g_sa_encode[tt] can also be,
#'  requested:[PAR],
#'
#'  Option [TT]-entropy[tt] writes the Shannon entropy of each position to an [TT].xvg[tt] file,
#'  ([TT]-Hlf[tt] for local fit or [TT]-Hgf[tt] for global fit).[PAR],
#'
#'  Option [TT]-profile[tt] writes the relative frequency of each letter at each position,
#'  to an ASCII [TT].dat[tt] file ([TT]-prolf[tt] for local fit or [TT]-progf[tt] for global fit).[PAR],
#'
#'  Option [TT]-xpm[tt] writes the alignment in [TT].xpm[tt] format: this can be converted to,
#'  postscript with [TT]xpm2ps[tt] for an immediate visualization of the time evolution,
#'  of the encoding for each position. The name of the [TT].xpm[tt] file can be specified,
#'  with the [TT]-xpm[tt] flag.
#'
#'
#' @param sa.mat Alignment of structural alphabet strings
#'
#' @return structural alphabet string
#'
#' @export

## test SA alignment matrix
testmat = function(num.row){
	sa.mat = matrix(nrow = num.row, ncol = 21)
	sa.mat[1,] = c('U','W','U','U','U','U','U', 'U','W','U','U','U','U','U', 'U','W','U','U','U','U','U')
	sa.mat[2,] = c('X','U','U','U','U','W','V', 'X','U','U','U','U','W','V', 'X','U','U','U','U','W','V')
	sa.mat[3,] = c('X','U','U','W','U','U','W', 'X','U','U','W','U','U','W', 'X','U','U','W','U','U','W')
	sa.mat[4,] = c('W','U','U','U','V','U','W', 'W','U','U','U','V','U','W', 'W','U','U','U','V','U','W')
	sa.mat[5,] = c('W','U','U','U','U','W','W', 'W','U','U','U','U','W','W', 'W','U','U','U','U','W','W')
	sa.mat[6,] = c('W','U','U','U','U','W','W', 'W','U','U','U','U','W','W', 'W','U','U','U','U','W','W')
 	sa.mat[7,] = c('W','U','U','U','U','W','W', 'W','U','U','U','U','W','W', 'W','U','U','U','U','W','W')
 	sa.mat[8,] = c('W','U','U','U','U','W','W', 'W','U','U','U','U','W','W', 'W','U','U','U','U','W','W')
 	sa.mat[9,] = c('W','U','U','U','U','W','W', 'W','U','U','U','U','W','W', 'W','U','U','U','U','W','W')
 	sa.mat[c(10:num.row),] = c('W','U','U','U','U','W','W', 'W','U','U','U','U','W','W', 'W','U','U','U','U','W','W')

 	return(sa.mat)
};

 ## time complexity test of the mutual information calculation
 t.comp.row = function(num.col){

 	## initialise an SA alignment matrix with a defined number of rows
 	sa.mat = matrix(nrow = 100, ncol = num.col)
 	sa.mat[c(1:100),] = rep(c('W'), ncol = num.col)

 	## calculate the time taken to compute the mutual information matrix
 	tt = system.time(

 		mi_mat(sa.mat)

 		)[1]

 	## return the system time
 	return(tt)


};

## calculate and plot the time complexity
cal.time.complex = function(maxin){

	tt.comp = c()

	for(x in seq(from = 10, to = maxin, by = 1)){
		tt = t.comp.row(x)

		tt.comp = append(tt.comp, tt)

		print(paste('[', (x/maxin)*100, '%]', sep=''))

		}

	return(tt.comp)
}


## calculate the probability matrix for all columns of the alignment
## as a pre-compiled matrix
probmat = function(sa.mat){

	## check that both user-defined columns are not the same
	#if(col1 == col2){
	#	stop('Select distinct columns in the structural alphabet alignment',
	#		call = TRUE)
	#};

	## dimensions of the alignment matrix
	d = dim(sa.mat);

	## determine the summary statistics of the alignment
	pm = list()
	for(i in seq(1, d[2])){
		pm[[i]] = table(sa.mat[,i])

	}

	#pm = apply(sa.mat, 2, function(x){table(x)});

	## calculate the probabilities of each letter in the columns
	ppm = lapply(pm, function(x){ x / d[1] });

	## initiate a complete probability matrix
	pmat = matrix(nrow = d[2], ncol = 25);

	## each row corresponds to a letter in the structural alphabet
	fragment_letters = c('A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y');

	colnames(pmat) = fragment_letters;

	## melt the probability matrix
	nm = reshape2::melt(ppm);

	## populate a complete probability matrix for each possible letter by matching to the 
	## correct letter in the alphabet
	pmat[matrix(c(nm$L1, match(nm$Var1, colnames(pmat))), ncol = 2)] = unlist(ppm);

	## fill in the zeros to the probability matrix
	pmat[is.na(pmat)] = 0;

	## return the probability matrix
	tpmat = (t(pmat));
	return(tpmat);

	## remove columns which have zero probabilities

}


## calculate the pair probability matrix
pairprobmat = function(sa.mat, col1, col2){

	## check that both user-defined columns are not the same
	if(col1 == col2){
		stop('Select distinct columns in the structural alphabet alignment',
			call = TRUE);
	};

	## determine the propability matrix for user-defined columns
	## 1 and 2 of the structural alphabet alignment matrix
	sa.mat = sa.mat[,c(col1,col2)];

	## unique fragments in the first and second columns of the alignment
	col1.frags = unique(sa.mat[,1]);
	col2.frags = unique(sa.mat[,2]);

	## initialise a matrix to contain the pair probabilities
	pp.mat = matrix(0, ncol = length(col1.frags), nrow = length(col2.frags));
	colnames(pp.mat) = col1.frags;
	rownames(pp.mat) = col2.frags;


	## determine the pair probabilities
	p = paste(sa.mat[,1], sa.mat[,2]);
	pp = table(p) / length(p);

	## melt the probability matrix
	nm = reshape2::melt(pp);
	names(nm) = c('fcomb', 'prob');

	## return the pair probability matrix
	return(nm);
}


## compute the mutual information between two columns of the alignment
column_MI = function(prob.matrix, paired.prob.matrix){

	## compute the probability matrix for both columns of the alignment
	p = prob.matrix;

	## compute the paired probability matrix for both columns of the alignment
	pp = paired.prob.matrix;

	## sapply over each pair in the paired probability matrix
	mi = sum(sapply(1:nrow(pp), function(x){

		## dereference fragment in position 1
		f1 = substr(pp[x, 'fcomb'], 1, 1)

		## dereference fragment in position 2
		f2 = substr(pp[x, 'fcomb'], 3, 3)

		## dereference paired probability
		pf1pf2 = pp[x, 'prob']

		## look up probability of f1 in the probability matrix
		pf1 = p[f1, 1]

		## look up probability of f2 in the probability matrix
		pf2 = p[f2, 2]

		## determine the elements of the mutual information term
		Iprobs = pf1pf2 * log2( pf1pf2 / (pf1 * pf2) )
	
	}));

	## return the mutual information
	return(mi)


};


## compute the joint entropy between two columns of the alignment
column_entropy = function(prob.matrix, paired.prob.matrix){

	## compute the probability matrix for both columns of the alignment
	p = prob.matrix;

	## compute the paired probability matrix for both columns of the alignment
	pp = paired.prob.matrix;

	## sapply over each pair in the paired probability matrix
	je = -1* sum(sapply(1:nrow(pp), function(x){

		## dereference paired probability
		pf1pf2 = pp[x, 'prob']

		## determine the elements of the joint entropy term
		(pf1pf2 * log2(pf1pf2))
	}));

	## return the joint entropy
	return(je);
};


## compute the finite size error term between two columns of the alignment
column_fs_error = function(sa.mat, prob.matrix, paired.prob.matrix){

	## compute the probability matrix for both columns of the alignment
	p = prob.matrix;

	## compute the paired probability matrix for both columns of the alignment
	pp = paired.prob.matrix;

	## determine the number of non-zero probabilites for P(X,Y)
	bxy = nrow(pp);

	## determine the number of non-zero probabilites for P(X)
	bx = table(p[,1] > 0)['TRUE'];

	## determine the number of non-zero probabilites for P(Y)
	by = table(p[,2] > 0)['TRUE'];

	## determine the sample size (ie. the depth of the alignment)
	n = nrow(sa.mat);

	## compute the finite size error
	epsilon = (bxy - bx - by + 1) / (2 * n);

	## return the finite size error
	return(epsilon);
};


## compute the normalised mutual information between two columns of the alignment
column_norm_MI = function(sa.mat, prob.matrix, col1, col2){

	## compute the probability matrix for both columns of the alignment
	p = cbind(prob.matrix[,col1], prob.matrix[,col2]);

	## compute the paired probability matrix for both columns of the alignment
	pp = pairprobmat(sa.mat, col1, col2);

	## determine the mutual information
	I = column_MI(p, pp);

	## determine the joint entropy
	H = column_entropy(p, pp);

	## determine the finite size error term
	e = column_fs_error(sa.mat, p, pp);

	## termine the normalised mutual information
	nI = (I - e) / H

	## return the mutual information
	return(nI)
};


## compute the complete mutual information matrix for each column pair
## of the structural alphabet alignment
mi_mat = function(sa.mat){

	## determine the number of fragment positions in the alignment
	v = seq(1,dim(sa.mat)[2]);

	## initialise a v*v matrix
	mi.mat = matrix(0, nrow = length(v), ncol = length(v));

	## determine the pairs of columns over which to compute the mutual
	## information
	combinations = combn(v,2);

	## pre-compile the marginal probability matrix
	p.matrix = probmat(sa.mat);

	## apply over each of the combinations
	#sapply(c(1:ncol(combinations)), function(x){
	for(x in c(1:ncol(combinations))){
		## column position 1
		pos1 = combinations[1,x]

		## column position 2
		pos2 = combinations[2,x]
		
		## determine the mutual information for each combination of positions
		mi.col = column_norm_MI(sa.mat, p.matrix, pos1, pos2)

		#print(mi.col)

		## populate the v*v mutual information matrix
		mi.mat[pos1, pos2] = mi.col

		## populate the lower triangle of the mutual information matrix
		mi.mat[pos2, pos1] = mi.col

	};

	## normalise the mutual information matrix
	norm.mi.mat = mi.mat / max(mi.mat);

	## set diagonal equal to 1
	diag(norm.mi.mat) = 1;

	## return the mutual information matrix
	return(norm.mi.mat);
};














