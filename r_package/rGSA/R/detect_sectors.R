#' Automated detection of ergodic sectors from a list of time-averaged mutual information matrices.
#' 
#' This function takes an input matrix and extract so-called ergodic sectors. The input is a single
#' matrix generated by matrix_smooth(), and returns a summary of any detected ergodic sectors, and
#' when they occur in the MD simulation.
#'
#' @param overlap.matrix.s Smoothed matrix of covariance overlaps, computed using matrix_smooth()
#' @param sBlock trajectory block size (in ns)
#' @return Returns a dataframe containing a summary of any detected ergodic sectors, including the 
#' time in the MD trajectory in which they occur
#' @export 



detect_sectors = function(overlap.matrix.s, sBlock){

	## vector containing the diagonal of the smoothed covariance matrix
	sector.v = diag(overlap.matrix.s$z)

	## split the diagonal into sectors, here done for each quantile
	sector.liv = sapply(quantile(sector.v), function(x) x > sector.v)


	## the 'FALSE' sectors at 75% should be useful
	sector.sel.niv = which(! sector.liv[ ,"75%"])

	sector.idx = 1

	sector.idx.v = vector(length = length(sector.sel.niv))

	sector.idx.v[1] = sector.idx


	## count non-index-contiguous blocks
	for (i in 2:length(sector.sel.niv)) {

		if (sector.sel.niv[i-1] != sector.sel.niv[i] - 1) {

			sector.idx = sector.idx + 1

		}

		sector.idx.v[i] = sector.idx;
	}


	## translate block index vector into trajectory index vector
	sector.sel.tiv = sector.sel.niv * sBlock;

	## combine block index with trajectory index
	sector.info = rbind(sector.idx.v, sector.sel.niv, sector.sel.tiv)

	rownames(sector.info) = c("sector_ID", "block_idx", "traj_idx")

	# print out the time-indices of any detected ergodic sectors
	print(sector.info)

	# write the details of detected ergodic sectors to a file in the working dir
	print('Writing details of ergodic sectors to current working directory')

	write.table(sector.info,
		file = 'sector.info')

	## return the ergodic sector information
	return(sector.info)

}